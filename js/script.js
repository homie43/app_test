/* Задание на урок:
1) У нас уже есть рабочее приложение, состоящее из отдельных функций. Представьте, что
перед вами стоит задача переписать его так, чтобы все функции стали методами объекта personalMovieDB
Такое случается в реальных продуктах при смене технологий или подхода к архитектуре программы

2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

3) В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
при помощи метода forEach вывести в консоль сообщения в таком виде:
"Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/

'use strict';

const personalMovieDB = { // это наша База Данных, наш ГЛАВНЫЙ ОБЪЕКТ
    count: 0,
    movies: {},
    actors: {},
    genres: [],
    privat: false,
    start: function() {
        personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', ''); //мы указываем знаечение переменной внутри функции, что бы можно было его использовать
        // для проверки на то, нажал пользователь отмену или нет, в циукле ниже мы бутем отталкиваться от обратного, те проверяить неправильные варианты использования; если numberOfFilms пустая строка или пользователь нажал отмена(NaN) или isNaN проверяет что пользователь ввел именно число, а не набор букв. Если все это выполняется, то пользователю будет задан вопрос 'Сколько фильмов вы уже посмотрели?' заново.
        while (personalMovieDB.count == '' || personalMovieDB.count == null || isNaN(personalMovieDB.count)) { 
            personalMovieDB.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
        }
        //если пользователь вссе сделал правильно, то есть НЕ выполнил условий, указанных выше, то цикл считается завершенным
    },
    rememberMyFilms: function() { // на 3 практике мы обернули наш цикл в функцию
        for (let i = 0; i < 2; i++) {
            const a = prompt('Один из последних просмотренных фильмов?', '').trim(), // метод trim() удаляет пробелы в начале и конце строки
                  b = +prompt('На сколько оцените его?', '');
        
            if (a != null && b != null && a != '' && b != '' && a.length < 50) {//исходим от обратного: если в prompt нажать отмена, мы получим null, как раз это нам и нужно, чтобы пользователь не мог нажать отмена, если a не равна null, то дейтсвие выполняется, если пользователь нажал отмена, то  a = null; a != '' переменная не равна пустой строке, она должна быть заполнена; a.length < 50 означает что длинна символов не должна быть больше 50;
                personalMovieDB.movies[a] = b;
                alert('done');
            } else { //иначе будет ошибка
                alert('error');
                i--;
            }
        }
    },
    detectPersonalLevel: function() {
        if (personalMovieDB.count < 10) {
            alert('Просмотрено довольно мало фильмов');
        } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
            alert('Вы классический зритель');
        } else if (personalMovieDB.count >= 30) {
            alert('Вы киноман');
        } else {
            alert('Произошла ошибка');
        }
    },
    showMyDB: function(hidden) { // hidden аргумент
        if (hidden == false) { //если аргумент hidden - true, то значит в personalMovieDB.privat запишется значение true, то БД будет скрыта(приватна)
            console.log(personalMovieDB); // показывает базу данных
        }
    },
    toggleVisibleMyDB: function() {
        if (personalMovieDB.privat) {
            personalMovieDB.privat = false;
        } else {
            personalMovieDB.privat = true;
        }
    },
    writeYourGenres: function() {
        for (let i = 1; i < 2; i++) {
            // const question = prompt(`Ваш любимый жанр под номером ${i}`);
            // if (question == null || question == "") {
            //     alert('Вы ввели некорректные данные или не ввели их вовсе');
            //     i--;
            // } else {
            //     personalMovieDB.genres[i - 1] = question;
            // }
            
            const question = prompt(`Введите ваш любимый жанр через заяптую`).toLowerCase();
            if (question == null || question == "") {
                alert('Вы ввели некорректные данные или не ввели их вовсе');
                i--;
            } else {
                personalMovieDB.genres = question.split(', ');
                personalMovieDB.genres.sort();
            }
        }
        personalMovieDB.genres.forEach(function(item, i) {
            alert(`"Любимый жанр ${i + 1} - это ${item}"`);
        }); 
    }
};

// personalMovieDB.start();
// personalMovieDB.rememberMyFilms();
// personalMovieDB.detectPersonalLevel();
// personalMovieDB.showMyDB();
// personalMovieDB.toggleVisibleMyDB();
// personalMovieDB.writeYourGenres();

//1.3
// const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = +prompt('На сколько оцените его?', ''),
//       c = prompt('Один из последних просмотренных фильмов?', ''),
//       d = +prompt('На сколько оцените его?', '');

// personalMovieDB.movies[a] = b; обращаемся к обьекту personalMovieDB, потом через точку обращаемся к его свойству movies, которое тоже является объектом, потом через [], обращаемся к свойству a(можно так же через точку, но [] лучше), которого нет, но оно автоматически создается 
// - a - это ответ на первый вопрос, и он будет записан в качестве свойства
// - b - это ответ на второй вопрос и он будет записан в качестве значения этого свойства.

// personalMovieDB.movies[c] = d;

// Как итог, получим:

// const personalMovieDB = {
//     movies: {
//       q1: q2
//     }
// };
// Где a/b - это ответы пользователя

// Мы берем объект personalMovieDB и обращаемся к его свойству movies. Последний тоже является объектом, а значит может содержать свойства и их значения.При помощи записи movies[a] мы можем сделать 2 действия: либо получить свойство с именем а , либо, если его не существует - создать его.

// Так как объект movies еще пустой, то мы создаем новое свойство, которое будет называть так, какой ответ оставил пользователь в а. Теперь в это свойство мы бы хотели записать значение. Поэтому дальше идет присваивание:

// movies[a] = b;

// В b лежит ответ на второй вопрос и именно он помещается в свойство. Результат наглядно выглядит примерно так:

// movies['ответ на первый вопрос'] = "ответ на второй вопрос"
